## 代码生成可执行文件的过程

主要分为四个步骤

1.  预编译阶段：对g++编译器指定-E参数，生成.i文件。这个阶段的主要工作是将所有的宏展开，去掉所有的条件预编译指令，将所有的头文件包含进来，删除注释等。 
2.  编译阶段：对g++编译器指定-S参数，生成.s汇编文件。这个阶段的主要工作是对代码的语法，语义和词法等进行分析。
3.  汇编阶段: 对g++编译器指定-c参数，生成.o二进制文件。 
4.  链接阶段：将各个模块之间的相互引用处理好。把所有的静态库用到的目标文件装入程序中，并进行统一编址，然后进行重定位，即逻辑地址到物理地址的转换。

## 静态库与动态库

1.  静态库：命名方式为lib开头加上自定义的静态库名，然后以.a结尾。静态库实际上是一组目标文件的集合，再链接阶段与调用的程序生成可执行文件。静态库的优点在于：代码加载速度快，发布程序时，不需要提供对应的库；缺点时：可执行文件体积大，同时如果静态库有修改，调用的程序需要重新编译，而编译的耗时比较久。 
2.  动态库：命名方式为lib开头加上自定义的动态库名，然后以.so结尾。动态库首先生成与位置无关的目标文件，然后再运行时加载到内存。优点是：动态库可以共享，节省了系统资源，动态库进行修改后，无需重新编译。缺点是加载速度比静态链接慢，发布程序时，需要提供动态库。

## C和C++的区别

1.  设计思想上： C是面向过程的结构化语言，CPP是面向对象的语言 
2.  语法上： CPP具有三大特性，封装继承多态 CPP相对于C增加了许多类型安全的功能，比如四种强制类型转换 CPP支持范式编程，如模板类，函数模板等

## struct和class的区别

1.  共同点：C++中，可以用struct和class定义类，都可以继承。

2.  不同点：struct默认继承权限和默认访问权限时public class类的默认继承权限和访问权限时private。

## volatile关键字

对类型额外修饰的作用，类似于const。告诉编译器不要对这样的对象进行优化，因为该对象的值可能在程序的控制或检测之外被改变。

## static关键字555555555555

static的使用可以分为两类，一类是用在普通变量和函数上，另一类是用在类中。

1.  普通变量分为全局变量和局部变量。声明为静态全局变量时在**全局区分配内存**，并且**只在当前文件可见**，在文件之外是不可见的。其他文件定义同名变量不会发生冲突。变量的值**只在第一次执行时进行初始化**。声明为静态局部变量时与全局变量类似，只是**作用域为局部作用域**。

2.  静态普通函数，只在当前文件中可见，其他文件中定义同名函数不会发生冲突。
3.  static用在类中，首先是静态成员函数，**在类中声明，类外初始化。**所有对象共享一份数据。
4.  然后时静态成员函数：所有对象共享同一个函数，静态成员函数只能访问静态成员变量。

## const关键字

const 可以用于限定变量，指针和函数不可改变。

1.  如果是全局中的const变量，通常放在全局区。在局部声明的const变量放在栈区。

2.  const修饰成员函数时，函数中的变量不可改变，除非该变量特别声明为mutable

3.  const可以用来修饰指针，称为常量指针const int *p 指针的指向可以改变，但是不能改变指针指向的值。

4.  const修饰常量的指针叫做指针常量，int* const p 指针的指向不可以修改，指针指向的值可以修改。

**const可以明确指定类型，而宏定义没有数据类型。**

**define宏是在预处理阶段展开。const常量是编译运行阶段使用。**

**宏定义不分配内存，变量定义分配内存。**

## extern关键字55555555555555

1.  引入同一模块在其他文件中定义的**全局变量和函数**。
2.  如果在C++里调用了C库定义函数，那么需要使用`extern "C"` 标识这个函数，告诉编译器使用C的方式进行编译，防止C++的编译方式导致命令重整，无法找到对应的C函数。命名重整的原因在于**C++支持函数重载，而C不支持。**所以C++编译时增加了函数参数的标识符。

## this关键字

1.  解决同名冲突
2.  返回对象本身

this指针的本质是指针常量，指针的指向不可以修改。

## malloc和new555555555555555

相同点：malloc和new都是在堆上开辟内存，进行动态的管理。

不同点：

1.  new是关键字，malloc是库函数
2.  malloc只负责开辟内存，**没有初始化功能**。new不但能开辟内存，还可以初始化。
3.  malloc**必须指定开辟内存的大小**，**并且返回类型为void***，必须强制转换为实际类型的指针。new可以自动计算出所需内存的大小，并且返回指定类型的指针。
4.  malloc和new如果操作是内置数据类型两者基本类似，不同在于申请失败时。malloc申请失败时返回**NULL。**new申请失败**抛出bad_alloc异常**。
5.  自定义类型时，new先调用**operator new**函数申请空间，然后在申请的空间上执行**构造函数**。

## 内联函数和宏定义的区别

​    内联函数和宏的区别在于，宏是由**预处理器**对宏进行替代，而内联函数是通过**编译器**控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以像调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。内联函数与带参数的宏定义进行下比较，它们的代码效率是一样，但是内联欢函数要优于宏定义，因为**内联函数遵循的类型和作用域规则，它与一般函数更相近，**在一些编译器中，一旦关联上内联扩展，将与一般函数一样进行调用，比较方便。 

​    另外，**宏定义在使用时只是简单的文本替换，并没有做严格的参数检查，也就不能享受C++编译器严格类型检查的好处另外它的返回值也不能被强制转换为可转换的合适的类型**

​    C++的inline的提出就是为了完全取代宏定义，因为inline函数取消了宏定义的缺点，又很好地继承了宏定义的优点，《Effective C++》中就提到了尽量使用Inline替代宏定义的条款，足以说明inline的作用之大。

## 智能指针5555555

C++11有3个智能指针，分别是**unique_ptr, shared_ptr和weak_ptr**

1.  unique_ptr独享指针的所有权，无法进行拷贝构造赋值的操作，只能通过move函数进行所有权的转换。
2.  shared_ptr共享对象，它使用引用计数来保存当前有多少个智能指针在引用这个对象，当引用计数降为0时，对象会被销毁。
3.  weak_ptr称为**弱引用**，用于辅助shared_ptr正常工作，主要解决shared_ptr可能会产生的**环形引用问题**。weak_ptr不会增加对象的**引用计数**，共享指针可以直接赋值给弱指针，同时弱指针可以使用lock函数来获取shared_ptr对象

## move函数

将左值强制转换为右值引用，右值引用可以减少一次对象的析构和对象的构造。

## auto关键字

让编译器能够根据初始值的类型推断变量的类型。当处理复杂类型，比如STL中的类型时，优势最明显。`auto p = vt.begin()`

## 四种强制类型转换

1.  static_cast 低风险的转换，比如整数转浮点数，字符型转整形
2.  const_cast 去掉const关键字的转换，可以去掉带const的指针和引用
3.  dynamic_cast  使具有继承关系的基类转换位派生类，如果不可以转换则返回NULL
4.  reinterpret_cast 指针或引用的转换，风险较高

## 构造函数不能是虚函数

因为编译器在构造对象时，必须要知道确切的类型，才能正确地生成对象。

## 析构函数

析构函数不是虚函数容易引起**内存泄漏**

## 内存泄漏

不再需要使用的内存单元，没有及时释放。valgrind检测内存泄漏的工具。

## 野指针

一些内存的单元已被释放，之前指向它的指针还在被使用。

## 多态5555555555

多态分类两大类：静态多态和动态多态。

静态多态是函数重载和运算符重载

动态动态：也叫运行时多态，是通过**继承和虚函数**实现的。在具有继承关系的子类中，子类重写父类的虚函数，通过父类引用或指针指向子类对象时，产生不同的行为叫做多态。

多态的核心原理在于**虚函数表指针**，每个对象都有一个虚函数表指针，虚函数表指针指向一张虚函数表，表中记录了虚函数的入口地址，如果子类重写虚函数后，这个地址就会替换掉。**多态的好处在于更方便程序的扩展，坏处在于每个对象多了一个4字节的指针，同时每次查询虚函数表需要耗时。**

## 写一个函数在main函数执行前先运行

```c++
#include <iostream>
using namespace std;
class Hello{
public:
	Hello(){
		cout<<"before main!"<<endl;
	}
};
Hello w; //全局变量在main之前执行 
int main(){
	cout<<"I am main"<<endl;
	return 0;
}
```

