## epoll的优势

连接的文件描述符比较多，但是活跃的文件描述符比较少时，比select和poll效率更高。

epoll三个主要的函数：

1.  epoll_create() 
2.  epoll_ctl() 
3.  epoll_wait()

## ET和LT的区别

1.  ET称为边沿触发，在调用epoll_wait函数监听的时候，如果有满足的事件，则该函数进行返回，返回值是满足监听事件的文件描述符数量。ET模式下，只会响应一次，即使部分文件描述符的事件没有进行处理。
2.  LT称为水平触发，如果epoll_wait有满足条件的事件，会一直返回。增加了epoll_wait函数的调用次数。所以通常在并发服务器上，多使用ET模式。如果系统中有大量不需要读写的就绪文件描述符，而它每次都会返回，这样会大大降低检索自己关心的就绪文件描述符的效率。

## ET为什么要用非阻塞而不是阻塞

1.  阻塞模式，程序在读取数据时无法知道什么时候读完，会一直阻塞在read函数上，即使已经读完了数据。
2.  非阻塞模式，程序使用while循环读取数据，读完以后read会返回，errno被设置为EAGAIN。

## 五种网络IO模型

1.  阻塞IO
2.  非阻塞IO
3.  IO多路复用
4.  信号驱动IO
5.  异步IO

>   前4个都是同步IO。IO多路复用也是阻塞的，但是没有阻塞在send和recv上，而是阻塞在select，poll和epoll上。

1.  同步：进程在数据由内核空间复制回进程缓冲区时不能干别的事。
2.  异步：在数据准备完成，由内核缓冲区拷贝到进程缓冲区后通知进程，在等待通知的这段事件里，进程可以干别的事情。



## 多智能体问题的难点

1.  强智能体和弱智能体。理论上：难点在于既要保护好已经聚集到一起的弱智能体，同时还要朝着目标点，以最快的速度赶过去。最开始尝试用强化学习做，先按照规则训练，然后将训练好的模型进行驱赶，效率还不错。但是强化学习只能针对特定的分布有效果，如果分布改变了又需要重新训练，而且有一篇文章中提到强化学习不利于实际的应用，规则越简单越好。于是提出仿照经典的bird模型进行改进，但是哪个模型是针对的同种智能体，而我们这个问题涉及到一个强智能体和一堆弱智能体。所以不断的看仿生的文章，然后考虑借鉴。最后在摸索的过程中得到一种似乎可行的方案，然后不断的改进，最后效果还不错。
2.  实践上：需要自己模拟两种智能体运动的过程，在二维平面上把智能体可以抽象为点，但是运动需要方向速度，还有智能体之间的排斥力和靠近局部中心的力，强智能体的驱赶力，抗干扰的随机力，前一次运动的惯性力。这些力和位移和计算还是挺繁琐的。判断一的智能体在另一个智能体的什么位置，使用叉积。碰撞到区域边缘时，如果是弹性碰撞，需要按照反射角的方向弹出。

